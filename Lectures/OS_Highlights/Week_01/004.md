---
marp: true
theme: academic
paginate: true
# footer: "What is an OS Really Doing (scaffolding with OpenAI GPT-5)"
style: ../../assets/msu-theme.css
header: "üê¥ MSU OpSys"
---

# üß© **System Calls & User/Kernel Boundaries**

> ‚ÄúCrossing the great divide: how your code talks to the hardware.‚Äù

---

## üí° Big Idea

User programs don‚Äôt get to touch hardware directly.  
Instead, they _ask_ the operating system to do it ‚Äî politely, through **system calls**.

This protects both the hardware and the rest of the system from accidental (or intentional) chaos.

---

## üß† Two Worlds: User Mode & Kernel Mode

| Mode            | Who Lives There      | Privileges                               |
| --------------- | -------------------- | ---------------------------------------- |
| **User Mode**   | Regular applications | Limited ‚Äî can‚Äôt access hardware directly |
| **Kernel Mode** | Operating system     | Full control of CPU, memory, devices     |

**Goal:** Prevent untrusted code from wrecking the system.

---

## üß© The Boundary in Action

When an app wants to:

- read a file
- open a socket
- allocate memory
- launch another process

‚Ä¶it makes a **system call** ‚Äî a controlled jump into kernel mode.

---

## ‚öôÔ∏è Example Flow: `read()` System Call

1. Program calls `read(fd, buffer, count)`
2. CPU executes a _trap_ (special instruction)
3. Hardware switches to **kernel mode**
4. OS checks permissions & performs operation
5. Data returned to user space
6. CPU switches back to **user mode**

The transition is brief but absolutely critical.

---

## üß† Trap vs Interrupt vs Exception

| Type          | Triggered By                     | Typical Use                                       |
| ------------- | -------------------------------- | ------------------------------------------------- |
| **Trap**      | Software instruction (`syscall`) | Enter kernel for a service                        |
| **Interrupt** | Hardware signal                  | Notify CPU of external event (e.g., I/O complete) |
| **Exception** | Fault or error in code           | Divide-by-zero, page fault                        |

They all change context ‚Äî traps are the polite version.

---

## üß© Why the Separation Exists

- **Security:** isolate untrusted code
- **Stability:** one crash ‚â† full crash
- **Fairness:** OS controls CPU scheduling
- **Abstraction:** user programs never need device-level details

Without this line, the OS becomes optional chaos.

---

## ‚öôÔ∏è Real Examples (Linux / POSIX)

| System Call          | Purpose                        |
| -------------------- | ------------------------------ |
| `fork()`             | Create a new process           |
| `exec()`             | Replace process image          |
| `wait()`             | Wait for a child to finish     |
| `read()` / `write()` | I/O operations                 |
| `open()` / `close()` | Manage file descriptors        |
| `mmap()`             | Map files or devices to memory |
| `ioctl()`            | Device-specific control        |

These are your application‚Äôs lifelines to the kernel.

---

## üß† Peek Under the Hood

```bash
$ strace ls
execve("/bin/ls", ["ls"], 0x7ffe8d9e05d0) = 0
brk(NULL) = 0x563fb1182000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f09e6d5d000
write(1, "Desktop\nDocuments\nDownloads\n", 29)
exit_group(0)
```

`strace` shows every system call `ls` makes ‚Äî dozens of them just to print filenames.

---

## üß© Inside the Kernel

System calls are implemented by:

1. A **dispatch table** mapping numbers ‚Üí kernel functions
2. Architecture-specific handlers (x86 ‚Üí `syscall`, ARM ‚Üí `svc`)
3. Privilege checks, memory translation, result return

It‚Äôs like a customer-service desk for software.

---

## ‚öôÔ∏è Return to User Mode

After the call:

1. Kernel places result (or errno) in a register
2. CPU clears the privileged bit
3. Execution resumes where it left off

To the programmer, it looks instant ‚Äî but hundreds of CPU cycles happen behind the curtain.

---

## üß© Security at the Boundary

- Validate arguments (pointers, buffer lengths)
- Enforce file and user permissions
- Prevent privilege escalation
- Guard against malicious or malformed inputs

**Most OS exploits live here** ‚Äî at the boundary between convenience and control.

---

## üß† Visualization Idea ‚Äì ‚ÄúCrossing the Line‚Äù

A two-column diagram:

```
User Space      |      Kernel Space
----------------|------------------------
printf()        | write()
malloc()        | brk()
socket()        | sys_socket()
read()          | sys_read()
```

Show arrows and mode switches ‚Äî a perfect 2-minute chalkboard or animated slide.

---

## üéØ Exit Prompt

> ‚ÄúWhy not just let user programs access hardware directly?‚Äù

Possible answers:

- Hardware conflicts
- Security risks
- Race conditions
- ‚ÄúBecause I like when my computer still boots tomorrow.‚Äù

---

## üíæ Summary

| Concept     | Core Idea                            |
| ----------- | ------------------------------------ |
| System Call | Controlled kernel entry for services |
| User Mode   | Restricted, safe environment         |
| Kernel Mode | All-powerful but protected           |
| Trap        | Software interrupt for syscalls      |
| Boundary    | Security, stability, sanity          |

---

## üß≠ Next Topic

**Next ‚ñ∂Ô∏è** [Week 2: Concurrency & Synchronization ](../Week_02/pdfs/001.pdf)

## üìö References & Credits

> **topic:** "Operating Systems Week 1 Lecture Slides"
> **focus:** "System Calls & User/Kernel Boundaries"
> **format:** "Markdown-based slide content"
> **author:** "T. Griffin and OpenAI GPT-5"
> **credit:** "Concept scaffolding with ChatGPT (OpenAI GPT-5)"

---

## üßê Definitions & distinguishing features

### Interrupt

- An interrupt is **typically asynchronous**, meaning it‚Äôs generated by something external to the current instruction stream. For example: a hardware device (keyboard press, disk I/O completion, timer expiry) sends a signal to the CPU that needs immediate attention. ([microcontrollertips.com][1])
- When an interrupt occurs the CPU _pauses_ what it was doing (or at least delays further instructions) and transfers control to an Interrupt Service Routine (ISR) or kernel handler. Then after the handler, it may resume the interrupted task. ([UW Computer Sciences][2])
- Interrupts can be **hardware-generated** (most common) or **software-generated** (less common). ([GeeksforGeeks][3])

### Exception

- An exception is a **synchronous** event: it happens because of the _current instruction_‚Äôs execution. For example: divide by zero, illegal opcode, memory access violation. ([GeeksforGeeks][4])
- It means ‚Äúsomething special/abnormal happened during execution‚Äù, so the CPU/OS needs to handle it (maybe kill the process, maybe fix up memory, maybe retry instruction). ([microcontrollertips.com][1])
- Some architectures treat exceptions as a category of interrupts (or alias them) but with specific semantics (synchronous vs asynchronous) so the term can overlap. ([Stack Overflow][5])

### Trap

- ‚ÄúTrap‚Äù is the trickiest term because it's used inconsistently. Often: a trap is a **synchronous software-interrupt** (or software-generated exception) used to transfer control to the OS/monitor. For example: system calls, break-points, or privileged instructions. ([Stack Overflow][6])
- In some definitions: a trap = a special kind of exception that is _expected_ and _intentional_. For example: a user program executes a `syscall` instruction which trips a trap to enter the kernel. ([plantation-productions.com][7])
- Another nuance: on x86 the hardware-terminology uses ‚Äúfault‚Äù, ‚Äútrap‚Äù, ‚Äúabort‚Äù as sub-categories of exceptions. ([vimalshekar.github.io][8])

---

## üìã Comparison table

Here‚Äôs a simple table (for your students) to summarise:

| Term      | Source / Trigger                                           | Timing relative to instruction        | Typical use                     |
| --------- | ---------------------------------------------------------- | ------------------------------------- | ------------------------------- |
| Interrupt | External event (hardware) or peripheral                    | Asynchronous (can happen anytime)     | I/O completion, timer, device   |
| Exception | Internal to CPU / instruction fault or special instruction | Synchronous (tied to the instruction) | Illegal operation, memory fault |
| Trap      | Software-generated (or special instruction)                | Synchronous                           | System call, debugger break     |

You might note that a trap is _technically_ a kind of exception or software interrupt in many texts‚Äîbut emphasizing the trigger/source and timing is key.

---

## üîç Some deeper notes for your course (and lab)

- When teaching OS/embedded systems, emphasise how the CPU transitions modes: for interrupts/exceptions/traps often the processor switches from user mode to kernel (supervisor) mode, saves context (registers/PC), jumps to a handler, then eventually resumes. ([cs.columbia.edu][9])
- On real hardware (say x86): there‚Äôs an Interrupt Descriptor Table (IDT) which covers hardware interrupts, exceptions, software interrupts/traps. ([Wikipedia][10])
- Embedded/MCU context: these terms also show up but definitions shift (e.g., ARM might treat everything as ‚Äúexception‚Äù but split into aborts, interrupts, resets). ([vimalshekar.github.io][8])
- For your IoT/mobile dev classes you might show a flow: ‚Äúsensor triggers hardware interrupt ‚Üí microcontroller ISR runs ‚Üí main loop resumed‚Äù vs ‚Äúprogram tries divide by zero ‚Üí exception/hardware trap triggered ‚Üí fault handler or OS kills process‚Äù.

---

## ‚úÖ My ‚Äúroast-and-pivot‚Äù for clarity

**Roast**: If you treat ‚Äúinterrupt‚Äù, ‚Äúexception‚Äù, and ‚Äútrap‚Äù as just random synonyms, your students will be left scratching their heads when the exam asks _‚ÄúWhat‚Äôs the difference between a trap and an interrupt?‚Äù_. Don‚Äôt do that.
**Pivot**: Teach them _why_ the distinction matters: source (hardware vs software), timing (async vs sync), and intent (user request vs fault vs device event). Then they‚Äôll actually _understand_ rather than just memorise.

---

[1]: https://www.microcontrollertips.com/exceptions-traps-and-interrupts-whats-the-difference-faq/?utm_source=chatgpt.com "Exceptions, traps, and interrupts, what's the difference?"
[2]: https://pages.cs.wisc.edu/~gerald/cs537/Summer17/handouts/traps.pdf?utm_source=chatgpt.com "[PDF] Chapter 3 Traps, interrupts, and drivers - cs.wisc.edu"
[3]: https://www.geeksforgeeks.org/difference-between-hardware-interrupt-and-software-interrupt/?utm_source=chatgpt.com "Difference Between Hardware Interrupt and Software Interrupt"
[4]: https://www.geeksforgeeks.org/computer-organization-architecture/difference-between-interrupt-and-exception/?utm_source=chatgpt.com "Difference between Interrupt and Exception - GeeksforGeeks"
[5]: https://stackoverflow.com/questions/45485093/signal-vs-exceptions-vs-hardware-interrupts-vs-traps?utm_source=chatgpt.com "Signal vs Exceptions vs Hardware Interrupts vs Traps - Stack Overflow"
[6]: https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt?utm_source=chatgpt.com "What is the difference between Trap and Interrupt? - Stack Overflow"
[7]: https://www.plantation-productions.com/Webster/www.artofasm.com/DOS/pdf/ch17.pdf?utm_source=chatgpt.com "[PDF] Interrupts, Traps, and Exceptions Chapter 17 - Plantation Productions"
[8]: https://vimalshekar.github.io/reverse-engg/Interrupts-and-Exceptions?utm_source=chatgpt.com "Interrupts and Exceptions"
[9]: https://www.cs.columbia.edu/~junfeng/11sp-w4118/lectures/trap.pdf?utm_source=chatgpt.com "[PDF] Chapter 3 System calls, exceptions, and interrupts - Columbia CS"
[10]: https://en.wikipedia.org/wiki/Interrupt_descriptor_table?utm_source=chatgpt.com "Interrupt descriptor table"
