---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys"
footer: "Readerâ€“Writer Problem â€” Griffin | GPT-5"
style: |
  h1, h2, h3 { color: #7a0019; }
  pre, code { font-size: 0.9em; }
---

# ğŸ“š The Readerâ€“Writer Problem

> â€œIf a writer edits the book while readers are still reading itâ€¦
> chaos follows â€” even faster than on Reddit.â€

---

## ğŸ’¡ Scenario

- Shared **data (a file, DB, memory segment)** accessed by multiple threads.
- **Readers** can access concurrently (no changes).
- **Writers** need exclusive access.

Goals:
âœ… Allow concurrent reading.
âœ… Only one writer at a time.
âœ… Prevent starvation.

---

## ğŸ§© Base Setup

```python
import threading, time, random

data = 0
readcount = 0
lock = threading.Lock()
rw_mutex = threading.Lock()
```

---

## âš ï¸ Attempt #1 â€“ The NaÃ¯ve Version

```python
def reader():
    global data
    while True:
        print(f"Reader sees {data}")
        time.sleep(random.uniform(0.3, 0.8))

def writer():
    global data
    while True:
        data += 1
        print(f"Writer updates data to {data}")
        time.sleep(random.uniform(0.5, 1.0))
```

ğŸ˜± **Race condition city:**

- Readers may read while writer is changing `data`.
- Multiple writers may update simultaneously.
- Result: corrupted or inconsistent data.

---

## ğŸ”’ Attempt #2 â€“ One Lock to Rule Them All

```python
def reader():
    while True:
        with lock:
            print(f"Reader sees {data}")
        time.sleep(random.uniform(0.3, 0.8))

def writer():
    global data
    while True:
        with lock:
            data += 1
            print(f"Writer updates data to {data}")
        time.sleep(random.uniform(0.5, 1.0))
```

âœ… Safe
âŒ No concurrency at all â€” readers block each other unnecessarily.

> â€œYouâ€™ve solved chaos by banning everyone from the library.â€

---

## ğŸ“– Attempt #3 â€“ Reader-Priority Solution

Allow multiple readers but lock out writers when any reader is active.

```python
readcount = 0
mutex = threading.Lock()      # protects readcount
rw_mutex = threading.Lock()   # writer exclusion

def reader(id):
    global readcount
    while True:
        with mutex:
            readcount += 1
            if readcount == 1:
                rw_mutex.acquire()  # first reader blocks writers
        print(f"ğŸ‘“ Reader {id} reads {data}")
        time.sleep(random.uniform(0.3, 0.8))
        with mutex:
            readcount -= 1
            if readcount == 0:
                rw_mutex.release()  # last reader unblocks writers
        time.sleep(random.uniform(0.2, 0.6))

def writer(id):
    global data
    while True:
        rw_mutex.acquire()
        data += 1
        print(f"âœï¸ Writer {id} updates data to {data}")
        rw_mutex.release()
        time.sleep(random.uniform(0.5, 1.0))
```

âœ… Readers can overlap
âŒ Writers may **starve** if readers keep coming

> â€œEndless readers = hangry writers.â€

---

## âœï¸ Attempt #4 â€“ Writer-Priority Solution

Writers wait for readers, but new readers must wait if a writer is waiting.

```python
readcount = 0
writecount = 0

mutex = threading.Lock()
rw_mutex = threading.Lock()
readTry = threading.Lock()
resource = threading.Lock()

def reader(id):
    global readcount
    while True:
        readTry.acquire()
        mutex.acquire()
        readcount += 1
        if readcount == 1:
            resource.acquire()
        mutex.release()
        readTry.release()

        print(f"ğŸ‘“ Reader {id} reads {data}")
        time.sleep(random.uniform(0.3, 0.8))

        mutex.acquire()
        readcount -= 1
        if readcount == 0:
            resource.release()
        mutex.release()
        time.sleep(random.uniform(0.2, 0.6))

def writer(id):
    global data, writecount
    while True:
        rw_mutex.acquire()
        writecount += 1
        if writecount == 1:
            readTry.acquire()
        rw_mutex.release()

        resource.acquire()
        data += 1
        print(f"âœï¸ Writer {id} updates data to {data}")
        resource.release()

        rw_mutex.acquire()
        writecount -= 1
        if writecount == 0:
            readTry.release()
        rw_mutex.release()
        time.sleep(random.uniform(0.5, 1.0))
```

âœ… Prevents writer starvation
âœ… Ensures fairness
âš™ï¸ Slightly more complex coordination

---

## ğŸ§  Summary

| Approach        | Concurrency | Fairness | Notes              |
| --------------- | ----------- | -------- | ------------------ |
| NaÃ¯ve           | âŒ          | âŒ       | Chaos              |
| One Lock        | âŒ          | âœ…       | Overly safe        |
| Reader-Priority | âœ…          | âŒ       | Writers may starve |
| Writer-Priority | âœ…          | âœ…       | Balanced and fair  |

---

## ğŸ§© Main Function

```python
def main():
    threads = []
    for i in range(3):
        t = threading.Thread(target=reader, args=(i,), daemon=True)
        threads.append(t)
        t.start()
    for i in range(2):
        t = threading.Thread(target=writer, args=(i,), daemon=True)
        threads.append(t)
        t.start()
    time.sleep(10)
    print("Simulation complete.")
```

---

## ğŸ§© OS Concepts

| OS Idea          | Analogy                      |
| ---------------- | ---------------------------- |
| Reader           | Process doing `read()`       |
| Writer           | Process doing `write()`      |
| Critical Section | Shared memory region         |
| Semaphore        | Access permit                |
| Starvation       | A writer never gets CPU time |

---

## ğŸ Takeaway

> â€œThe Readerâ€“Writer problem teaches one hard truth:
> **Sometimes fairness means making everyone wait a little.**â€
