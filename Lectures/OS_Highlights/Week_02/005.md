---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys â€” Synchronization Strategies"
footer: "MSU Texas â€¢ Department of Computer Science"
style: ../../assets/msu-theme.css
---

# ğŸ½ï¸ **Dining Philosophers in Python**

> â€œFive philosophers walk into a table. None eat. Concurrency ensues.â€

<center><img src="https://images2.imgbox.com/48/63/8VOFlBDr_o.png" width="300"></center>

---

## ğŸ’¡ **The Setup**

- Five **threads** (philosophers) share **five forks** (locks).
- Each must acquire **two forks** to eat.
- We want:

  - No deadlock
  - No starvation
  - Everyone eats eventually

---

## âš™ï¸ Imports & Base Code

```python
import threading, time, random

N = 5
forks = [threading.Lock() for _ in range(N)]
names = ["Aristotle", "Kant", "Spinoza", "Marx", "Russell"]

def think(name):
    print(f"{name} is thinking...")
    time.sleep(random.uniform(0.5, 1.5))

def eat(name):
    print(f"ğŸ {name} is eating!")
    time.sleep(random.uniform(0.5, 1.5))
```

---

## ğŸ˜¬ Attempt #1 â€“ NaÃ¯ve Approach

```python
def philosopher(i):
    left = forks[i]
    right = forks[(i + 1) % N]
    name = names[i]

    while True:
        think(name)
        left.acquire()
        right.acquire()
        eat(name)
        right.release()
        left.release()
```

ğŸ’¥ Deadlock: everyone grabs left fork, waits forever for right fork.

---

## ğŸ§™ Attempt #2 â€“ The â€œOne Weird Philosopherâ€ Fix

```python
def philosopher(i):
    left = forks[i]
    right = forks[(i + 1) % N]
    name = names[i]

    while True:
        think(name)
        if i == N - 1:
            right.acquire()
            left.acquire()
        else:
            left.acquire()
            right.acquire()
        eat(name)
        right.release()
        left.release()
```

âœ… Avoids deadlock
ğŸ˜¬ But brittle â€” depends on arbitrary ordering.

---

## ğŸ½ï¸ Attempt #3 â€“ The Waiter (Semaphore) Solution

Only 4 philosophers can pick up forks at once.

```python
waiter = threading.Semaphore(N - 1)

def philosopher(i):
    left = forks[i]
    right = forks[(i + 1) % N]
    name = names[i]

    while True:
        think(name)
        waiter.acquire()
        left.acquire()
        right.acquire()
        eat(name)
        right.release()
        left.release()
        waiter.release()
```

âœ… No deadlock
âš ï¸ Still possible for starvation (bad luck scheduling)

---

## ğŸ§‘â€ğŸ³ Attempt #4 â€“ Fair Waiter (Queueing)

Simulate fairness with timed waiting and priority.

```python
lock = threading.Lock()
next_turn = 0

def philosopher(i):
    global next_turn
    left, right = forks[i], forks[(i + 1) % N]
    name = names[i]

    while True:
        think(name)
        with lock:
            my_turn = next_turn
            next_turn += 1

        while True:
            with lock:
                if my_turn == 0:
                    break
            time.sleep(0.1)  # politely wait

        left.acquire()
        right.acquire()
        eat(name)
        right.release()
        left.release()

        with lock:
            next_turn = (next_turn + 1) % N
```

âœ… Everyone eventually eats
âœ… Still conceptually clear
âŒ Slightly more bookkeeping

---

## ğŸ§© Alternative: Using `threading.Condition`

Pythonâ€™s closest thing to a monitor.

```python
condition = threading.Condition()
state = ["thinking"] * N

def left(i):  return (i + N - 1) % N
def right(i): return (i + 1) % N

def test(i):
    return (state[i] == "hungry" and
            state[left(i)] != "eating" and
            state[right(i)] != "eating")

def pickup(i):
    with condition:
        state[i] = "hungry"
        while not test(i):
            condition.wait()
        state[i] = "eating"

def putdown(i):
    with condition:
        state[i] = "thinking"
        condition.notify_all()
```

âœ… True monitor pattern
âœ… No deadlock or starvation
ğŸ¤“ Ideal for teaching higher-level concurrency

---

## ğŸ§® Summary

| Version           | Deadlock | Starvation | Difficulty  | Comment           |
| ----------------- | -------- | ---------- | ----------- | ----------------- |
| NaÃ¯ve             | âŒ       | âŒ         | ğŸª‘ Easy     | Everyone selfish  |
| Weird Philosopher | âœ…       | âŒ         | ğŸ«  Hacky     | Works by luck     |
| Semaphore Waiter  | âœ…       | âš ï¸ Maybe   | ğŸ™‚ Medium   | Practical         |
| Fair Waiter       | âœ…       | âœ…         | ğŸ˜Œ Moderate | Orderly           |
| Monitor           | âœ…       | âœ…         | ğŸ¤“ Advanced | Best conceptually |

---

### ğŸ§© **Why Monitors Matter**

- They **simplify synchronization logic** by hiding low-level lock management.
- They prevent common race-condition nightmares (where a mutex might be forgotten or misused).
- They influenced **modern concurrency abstractions**, like:

  - Javaâ€™s `synchronized` methods and `wait()/notify()`
  - Pythonâ€™s `threading.Condition`
  - C++â€™s condition variables inside class methods

---

### âš–ï¸ **Comparison: Monitor vs Semaphore**

| Feature                        | Monitor                       | Semaphore                                     |
| ------------------------------ | ----------------------------- | --------------------------------------------- |
| **Level**                      | High-level (abstract)         | Low-level (primitive)                         |
| **Encapsulation**              | Yes â€” includes data + methods | No â€” global synchronization variable          |
| **Automatic mutual exclusion** | Yes                           | Must be done manually                         |
| **Ease of use**                | Easier, safer                 | Prone to errors (e.g., forgetting `signal()`) |

---

### ğŸ—£ï¸ **Plain-English Summary**

A **monitor** is like a **traffic light with built-in rules**:

- Only one car (thread) can be in the intersection (shared resource) at a time.
- Cars can **wait** when the light is red (condition not met).
- When conditions change, the light turns green (`signal`) for the next waiting car.

### ğŸ§© **In Pseudocode**

```cpp
monitor BoundedBuffer {
    int buffer[N];
    int count = 0, in = 0, out = 0;
    condition notFull, notEmpty;

    procedure insert(item) {
        if (count == N) wait(notFull);
        buffer[in] = item;
        in = (in + 1) % N;
        count++;
        signal(notEmpty);
    }

    procedure remove() returns item {
        if (count == 0) wait(notEmpty);
        item = buffer[out];
        out = (out + 1) % N;
        count--;
        signal(notFull);
        return item;
    }
}
```

Here:

- Only one thread executes inside the monitor at a time.
- Threads can block (`wait`) and be woken (`signal`) based on conditions.

---

## ğŸ§  Discussion

- Why does resource ordering matter?
- How could this generalize to **N resources**?
- How might you simulate this visually (e.g., using `asyncio` or `pygame`)?

---

## ğŸ Closing Thought

> â€œThe Dining Philosophers problem doesnâ€™t teach you how to eat.
> It teaches you **how not to starve while sharing.**â€
