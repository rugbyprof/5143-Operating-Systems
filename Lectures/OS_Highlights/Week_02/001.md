---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys"
# footer: "What is an OS Really Doing (scaffolding with OpenAI GPT-5)"
# style: ../assets/msu-theme.css
style:
  section {
    font-size: 0.8em; /* shrink all slide text slightly */
  }
---

# âš™ï¸ **The Nature of Concurrency**

> â€œConcurrency isnâ€™t chaos â€” itâ€™s _managed unpredictability_.â€

- Multiple tasks **appear** to run at once.
- Sometimes they **actually** do (parallelism).
- Always about **coordination**, **resource sharing**, and **timing**.

<center>
<img src="https://images2.imgbox.com/b5/49/HklH7uJk_o.png" height="300">
</center>

---

## ğŸ§© **Parallel vs. Concurrent Execution**

| Concept        | Meaning                                                                                         | Example                                        |
| -------------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| **Parallel**   | Tasks truly run at the same time on multiple cores or CPUs.                                     | Two threads crunching math on different cores. |
| **Concurrent** | Tasks _overlap_ in time â€” they make progress independently, but not necessarily simultaneously. | A web server switching rapidly among requests. |

âœ… **Parallel** = _simultaneous_  
âœ… **Concurrent** = _interleaved_  
ğŸš« Confusing them = 3 AM debugging sadness.

---

## ğŸ§  **It's Stupid Analogy Time**

- â€œ**Parallelism** is like having multiple chefs cooking separate dishes.â€  
  <br>

- â€œ**Concurrency** is one chef juggling several dishes without burning anything.â€

<br>

Both aim to get dinner done, but the mental model and approach differs.

---

## ğŸ§® **Shared Resources & Nondeterminism**

- When two or more processes share:
  - CPU time
  - Memory (shared variables)
  - I/O devices
- Execution order becomes **nondeterministic**:

  > â€œWho gets the resource first?â€  
  > â€œWhat happens if two threads update the same value?â€

---

## ğŸ§® **Shared Resources & Nondeterminism**

Nondeterminism leads to:

- **Race conditions**
- **Deadlocks**
- **Inconsistent states**
- **Occasional student tears**

---

## ğŸ’¥ **Example: A Classic Race Condition**

```cpp
// Two threads both incrementing the same variable:
counter = counter + 1;
```

If interleaved like this:

| Thread A          | Thread B          |
| ----------------- | ----------------- |
| Reads counter (5) | Reads counter (5) |
| Adds 1 â†’ 6        | Adds 1 â†’ 6        |
| Writes 6          | Writes 6          |

```
Expected: 7
Actual  : 6 â†’ You just lost an increment
```

---

## ğŸ§° **Fixing It: Synchronization Primitives**

| Tool           | What It Does                             | Example                   |
| :------------- | :--------------------------------------- | :------------------------ |
| **Mutex**      | Mutual exclusion â€” one thread at a time. | `pthread_mutex_lock()`    |
| **Semaphore**  | Counter-based lock (n threads allowed).  | Producer-consumer queues  |
| **Monitor**    | Combines locks and condition variables.  | Java `synchronized` block |
| **Atomic Ops** | Hardware-level single-step updates.      | `std::atomic<int>`        |

Each protects shared resources â€” at the cost of some performance.

---

## ğŸŒ **Real-World Concurrency**

| Domain                | Example                                             | Why It Matters                                   |
| :-------------------- | :-------------------------------------------------- | :----------------------------------------------- |
| **Web servers**       | Handling thousands of simultaneous client requests. | Keeps user experiences smooth and scalable.      |
| **Operating systems** | Scheduling processes and threads.                   | Maximizes CPU utilization and fairness.          |
| **Databases**         | Multiple users reading/writing simultaneously.      | Ensures consistency with transactions and locks. |
| **IoT / Robotics**    | Sensors and actuators acting in parallel.           | Real-time response and coordination.             |

---

## â±ï¸ **Schedulers and Interleaving**

The OS scheduler decides **who runs next**:

- CPU-bound vs I/O-bound trade-offs.
- Context switching introduces overhead.
- Preemption ensures fairness.

You can simulate concurrency _even with one core_ by slicing time:

```text
T1:  â–ˆâ–ˆâ–ˆâ–ˆ----â–ˆâ–ˆâ–ˆâ–ˆ----
T2:  ----â–ˆâ–ˆâ–ˆâ–ˆ----â–ˆâ–ˆâ–ˆâ–ˆ
```

ğŸ‘† â€œLooks and feels parallelâ€ â€” but itâ€™s actually concurrent.

---

## ğŸ§© **Determinism vs. Nondeterminism**

| Type                 | Description                               | Example                                 |
| -------------------- | ----------------------------------------- | --------------------------------------- |
| **Deterministic**    | Same input â†’ same output every time.      | Pure functions, single-threaded code.   |
| **Nondeterministic** | Output depends on timing/order of events. | Multithreaded updates to shared memory. |

> Testing concurrent programs feels like herding cats â€” sometimes the bug just sleeps.

---

## ğŸ§  **Concurrency: The OSâ€™s Middle Name**

- The OS is the **referee**:
  - Prevents conflicts (mutexes, semaphores).
  - Allocates time (scheduler).
  - Keeps everyone fair and fed (resource management).
- But even the OS itself has to play by concurrencyâ€™s rules.

---

## ğŸ“ **Key Takeaways**

- Concurrency â‰  Parallelism â€” but they often coexist.
- Shared state introduces nondeterminism.
- Synchronization primitives tame chaos.
- The OS is the ultimate concurrency controller.

---

## ğŸ **Next Up: Synchronization Strategies**

> â€œLocks, semaphores, and monitors: controlling critical access to all threads across the globe.â€

Weâ€™ll explore:

- Critical sections
- Deadlocks & starvation
- Real-world scheduling examples
