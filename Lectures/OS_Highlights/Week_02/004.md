---
marp: true
theme: border
paginate: true
header: "ðŸ´ MSU OpSys â€” Deadlocks & Starvation"
footer: "Coffmanâ€™s Conditions â€¢ Detection â€¢ Prevention â€¢ Avoidance"
style: ../../assets/msu-theme.css
---

# ðŸ’€ **Deadlocks and Starvation**

> â€œWhen processes play tug-of-war for resources and _nobody wins_.â€

---

## ðŸ§© **What Is a Deadlock?**

A **deadlock** occurs when a set of processes are each waiting for an event that **only another process in the set can cause**.

ðŸ’¡ **In short:**

> Everyoneâ€™s waiting, nobodyâ€™s moving.

Example:

- Process A holds resource X, wants Y
- Process B holds resource Y, wants X  
  âž¡ï¸ _Classic deadlock._

---

## ðŸ§  **Coffmanâ€™s Four Conditions**

A deadlock can occur **only if all four** of these hold simultaneously:

| #   | Condition            | Meaning                                                                   |
| --- | -------------------- | ------------------------------------------------------------------------- |
| 1ï¸âƒ£  | **Mutual Exclusion** | Resources cannot be shared; one process at a time.                        |
| 2ï¸âƒ£  | **Hold and Wait**    | A process holds at least one resource and waits for more.                 |
| 3ï¸âƒ£  | **No Preemption**    | Resources canâ€™t be forcibly taken away.                                   |
| 4ï¸âƒ£  | **Circular Wait**    | A closed chain of processes each waiting for a resource held by the next. |

ðŸš« Breaking _any one_ of these conditions can prevent deadlock.

---

## ðŸ” **Visual: Circular Wait**

```
  â”Œâ”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”
  â”‚  P1 â”‚ â”€â”€â”€â–º â”‚  P2 â”‚
  â””â”€â”€â”¬â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”˜
     â”‚             â”‚
     â–¼             â–¼
   R1â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ R2
```

Each process holds one resource and waits for the other.  
The circle of doom is complete.

---

## ðŸ§® **Deadlock Handling Strategies**

Three main approaches:

| Approach          | Description                                                                                        | Cost                                            |
| ----------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| ðŸ§­ **Prevention** | Design the system to **avoid** satisfying all Coffman conditions simultaneously.                   | Restrictive but safe                            |
| ðŸš¨ **Detection**  | Allow deadlocks to occur, then **detect and recover**.                                             | Needs monitoring and recovery logic             |
| ðŸš¦ **Avoidance**  | Dynamically **analyze resource requests** and only grant them if they keep system in a safe state. | Requires future knowledge (e.g., maximum needs) |

---

## âš”ï¸ **1ï¸âƒ£ Deadlock Prevention**

Break at least one Coffman condition.

Examples:

- **No hold and wait:** Require all resources to be requested _at once_.
- **Preemption allowed:** Take resources away when needed.
- **Ordered resources:** Impose a strict order for requesting (break circular wait).

âœ… Simple  
âŒ Often inefficient â€” over-restrictive.

---

## ðŸ§­ **2ï¸âƒ£ Deadlock Avoidance**

Allow flexible allocation but **avoid unsafe states**.

Classic algorithm:

### ðŸ¦ **Bankerâ€™s Algorithm**

- Processes declare their maximum resource needs.
- System checks if granting a request keeps all processes in a _safe sequence_.
- If not safe â†’ deny temporarily.

ðŸ’¡ Works well in theory; harder in real systems where needs arenâ€™t predictable.

---

## ðŸ•µï¸ **3ï¸âƒ£ Deadlock Detection and Recovery**

Let deadlocks happen, then find and fix them.

**Detection:**

- Use a **wait-for graph**: edge from Pi â†’ Pj if Pi waits for a resource held by Pj.
- Deadlock â‡” cycle in the graph.

**Recovery:**

- Terminate or preempt one or more processes to break the cycle.

---

## ðŸ½ï¸ **Analogy: The Dining Philosophers**

- Each philosopher alternates between thinking and eating.
- Needs two forks (resources) to eat.
- If each philosopher grabs the left fork first â†’ ðŸ **deadlock.**

Solutions:

- Impose resource order (e.g., odd philosophers pick right fork first).
- Use a **waiter (monitor)** to grant forks safely.

---

## ðŸ§â€â™‚ï¸ **Starvation**

A process may **never get resources**, even if the system isnâ€™t deadlocked.

Causes:

- Unfair scheduling or resource allocation.
- Priority inversion â€” low-priority process holds a resource needed by high-priority one.

âž¡ï¸ Deadlock = _nobody progresses_  
âž¡ï¸ Starvation = _someone never progresses_

---

## ðŸ§  **Summary Table**

| Concept    | Description                             | Example Fix                    |
| ---------- | --------------------------------------- | ------------------------------ |
| Deadlock   | Circular wait; all stuck                | Break one Coffman condition    |
| Starvation | Process perpetually ignored             | Fair scheduling (e.g., aging)  |
| Prevention | Disallow at least one Coffman condition | Request all at once            |
| Avoidance  | Predict and avoid unsafe states         | Bankerâ€™s Algorithm             |
| Detection  | Find & recover from deadlocks           | Wait-for graph cycle detection |

---

## ðŸ§© **Takeaway**

> **Deadlock** is a standoff.  
> **Starvation** is neglect.  
> Both are solvable with discipline and design.
