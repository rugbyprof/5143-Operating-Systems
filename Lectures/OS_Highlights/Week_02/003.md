---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys â€” Synchronization Strategies"
footer: "MSU Texas â€¢ Department of Computer Science"
style: ../../assets/msu-theme.css
---

# ğŸ§© **Synchronization Strategies**

> â€œChaos is natural. Order is optional â€” unless you enforce it.â€

- Multiple threads want the same resource.
- Without discipline, **race conditions**, **deadlocks**, and **starvation** emerge.
- Synchronization ensures fairness, correctness, and sanity.

<center>
<img src="../assets/threads_tug_of_war.png" height="280">
</center>

---

## âš™ï¸ **The Critical Section Problem**

A **critical section** is a piece of code that accesses shared resources.

**Goal:**  
Only one thread executes it at a time.

```cpp
// Critical section (shared counter)
void increment() {
    counter++; // Only one thread allowed here
}
```

**Requirements:**

1. **Mutual exclusion** â€” only one thread inside.
2. **Progress** â€” someone gets in eventually.
3. **Bounded waiting** â€” nobody waits forever.

---

## ğŸ” **Synchronization Tools**

| Tool             | Description                                      | Example Use                  |
| :--------------- | :----------------------------------------------- | :--------------------------- |
| **Mutex (Lock)** | One thread at a time.                            | Protecting shared variables. |
| **Semaphore**    | Counter-based â€” allows _n_ simultaneous threads. | Producer/consumer buffers.   |
| **Monitor**      | Combines lock + condition variables.             | Java `synchronized` methods. |
| **Atomic Ops**   | Hardware-level single-step ops.                  | `std::atomic<int> counter++` |

> â€œLocks are like traffic lights â€” ignore them and everything crashes.â€

---

## ğŸš¦ **Visual: The Critical Section**

```
+-------------+     +-------------+
| Thread A    |     | Thread B    |
| wants entry |     | wants entry |
+------+------+     +------+------+
       |                    |
       v                    v
    [ Critical Section (shared data) ]
        ^                ^
        |                |
        +----------------+
    Mutual exclusion enforced
```

---

## ğŸ§® **Example: The Bank Account Problem**

```cpp
void deposit(int amount) {
    balance += amount;
}

void withdraw(int amount) {
    if (balance >= amount)
        balance:-= amount;
}
```

- Without a lock, `balance` can go negative.
- With a **mutex**, it stays consistent:
  ```cpp
  std::lock_guard<std::mutex> guard(mtx);
  balance += amount;
  ```

---

## âš”ï¸ **Deadlock**

> â€œA situation where each thread waits forever for the other to release a resource.â€

**Classic Example:**

```cpp
// Thread A
lock(mutex1);
lock(mutex2);

// Thread B
lock(mutex2);
lock(mutex1);
```

ğŸ’¥ Both are now waiting â€” forever.

<center>
<img src="../assets/deadlock_cycle.png" height="250">
</center>

---

## ğŸ§© **Four Necessary Conditions for Deadlock**

| Condition            | Meaning                                 |
| :------------------- | :-------------------------------------- |
| **Mutual exclusion** | Resource held by one process at a time. |
| **Hold and wait**    | Process holds one, requests another.    |
| **No preemption**    | Resource canâ€™t be forcibly taken away.  |
| **Circular wait**    | Circular chain of waiting processes.    |

Break any one of these â†’ prevent deadlock.

---

## ğŸ§° **Deadlock Handling Strategies**

| Strategy               | Idea                                                  | Example                              |
| :--------------------- | :---------------------------------------------------- | :----------------------------------- |
| **Prevention**         | Design system so at least one condition canâ€™t happen. | Always lock resources in same order. |
| **Avoidance**          | Detect unsafe states before allocating.               | Bankerâ€™s Algorithm.                  |
| **Detection/Recovery** | Let it happen, then fix it.                           | Timeout or kill one process.         |

---

## â³ **Starvation**

> â€œWhen a thread waits indefinitely because others keep getting served first.â€

**Example:**  
A low-priority thread never gets CPU because higher-priority threads dominate.

**Fixes:**

- Aging (gradually increase waiting threadâ€™s priority).
- Fair locks (FIFO order).
- Balanced scheduling policies.

---

## ğŸ§­ **Ordering and Priority Inversion**

Even with locks, bad ordering causes chaos.

**Priority inversion example:**

- Low-priority thread holds a lock.
- High-priority thread waits.
- Medium-priority thread runs endlessly.

ğŸ’€ High-priority thread starves until low-priority one releases.

**Real case:**  
NASAâ€™s _Mars Pathfinder_ (1997) reset mid-mission due to priority inversion bug.

---

## ğŸ§® **Illustration: Ordering & Hierarchy**

```
Resources: R1, R2, R3

Threads must always lock in increasing order:
  lock(R1) â†’ lock(R2) â†’ lock(R3)

If everyone follows this order â†’ no circular wait.
```

Think of it as _â€œThe Locking Chain of Command.â€_

---

## ğŸ§  **Summary**

| Concept              | Goal                      | Example Fix               |
| :------------------- | :------------------------ | :------------------------ |
| **Critical Section** | Protect shared resources. | Mutex / atomic ops.       |
| **Deadlock**         | Avoid permanent waiting.  | Order locks consistently. |
| **Starvation**       | Ensure fairness.          | Aging / fair locks.       |
| **Ordering**         | Prevent circular waits.   | Enforce lock hierarchy.   |

> â€œSynchronization isnâ€™t about control â€” itâ€™s about coordination.â€

---

## ğŸ“ **Next: The OS as Referee**

> â€œWho gets the CPU, who gets the disk, who gets the lock.â€

Next section:

- Scheduling Algorithms (Round-Robin, Priority, Multilevel Queue)
- Context switching
- Cooperative vs Preemptive systems
