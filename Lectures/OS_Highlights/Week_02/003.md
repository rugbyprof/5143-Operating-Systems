---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys â€” Synchronization Strategies"
footer: "MSU Texas â€¢ Department of Computer Science"
style: ../../assets/msu-theme.css
---

# ğŸ§© **Synchronization Strategies**

> â€œChaos is natural. Order is optional â€” unless you enforce it.â€

- Multiple threads want the same resource.
- Without discipline, **race conditions**, **deadlocks**, and **starvation** emerge.
- Synchronization ensures fairness, correctness, and sanity.

<center>
<img src="https://images2.imgbox.com/02/c2/qwZL1kJ8_o.jpg" height="280">
</center>

---

## âš™ï¸ **The Critical Section Problem**

A **critical section** is a piece of code that accesses shared resources.

**Goal:**  
Only one thread executes it at a time.

```cpp
// Critical section (shared counter)
void increment() {
    counter++; // Only one thread allowed here
}
```

**Requirements:**

1. **Mutual exclusion** â€” only one thread inside.
2. **Progress** â€” someone gets in eventually.
3. **Bounded waiting** â€” nobody waits forever.

---

## ğŸ” **Synchronization Tools**

| Tool             | Description                                      | Example Use                  |
| :--------------- | :----------------------------------------------- | :--------------------------- |
| **Mutex (Lock)** | One thread at a time.                            | Protecting shared variables. |
| **Semaphore**    | Counter-based â€” allows _n_ simultaneous threads. | Producer/consumer buffers.   |
| **Monitor**      | Combines lock + condition variables.             | Java `synchronized` methods. |
| **Atomic Ops**   | Hardware-level single-step ops.                  | `std::atomic<int> counter++` |

> â€œLocks are like traffic lights â€” ignore them and everything crashes.â€

---

## ğŸš¦ **Visual: The Critical Section**

```
+-------------+     +-------------+
| Thread A    |     | Thread B    |
| wants entry |     | wants entry |
+------+------+     +------+------+
       |                    |
       v                    v
    [ Critical Section (shared data) ]
        ^                ^
        |                |
        +----------------+
    Mutual exclusion enforced
```

---

## ğŸ§® **Example: The Bank Account Problem**

```cpp
void deposit(int amount) {
    balance += amount;
}

void withdraw(int amount) {
    if (balance >= amount)
        balance:-= amount;
}
```

- Without a lock, `balance` can go negative.
- With a **mutex**, it stays consistent:
  ```cpp
  std::lock_guard<std::mutex> guard(mtx);
  balance += amount;
  ```

---

## âš”ï¸ **Deadlock**

> â€œA situation where each thread waits forever for the other to release a resource.â€

**Classic Example:**

```cpp
// Thread A
lock(mutex1);
lock(mutex2);

// Thread B
lock(mutex2);
lock(mutex1);
```

ğŸ’¥ Both are now waiting â€” forever.

<center>
<img src="../assets/deadlock_cycle.png" height="250">
</center>

> <sup>Deadlocks discussed next section</sup>

---

## ğŸ§­ **Ordering and Priority Inversion**

Even with locks, bad ordering causes chaos.

**Priority inversion example:**

- Low-priority thread holds a lock.
- High-priority thread waits.
- Medium-priority thread runs endlessly.

ğŸ’€ High-priority thread starves until low-priority one releases.

**Real case:**  
NASAâ€™s _Mars Pathfinder_ (1997) reset mid-mission due to priority inversion bug.

---

## ğŸ§® **Illustration: Ordering & Hierarchy**

```
Resources: R1, R2, R3

Threads must always lock in increasing order:
  lock(R1) â†’ lock(R2) â†’ lock(R3)

If everyone follows this order â†’ no circular wait.
```

Think of it as _â€œThe Locking Chain of Command.â€_

---

## ğŸ§  **Summary**

| Concept              | Goal                      | Example Fix               |
| :------------------- | :------------------------ | :------------------------ |
| **Critical Section** | Protect shared resources. | Mutex / atomic ops.       |
| **Deadlock**         | Avoid permanent waiting.  | Order locks consistently. |
| **Starvation**       | Ensure fairness.          | Aging / fair locks.       |
| **Ordering**         | Prevent circular waits.   | Enforce lock hierarchy.   |

> â€œSynchronization isnâ€™t about control â€” itâ€™s about coordination.â€

---

## ğŸ“ **Next: The OS as Referee**

> â€œWho gets the CPU, who gets the disk, who gets the lock.â€

Next section:

- Dining Philosophers
