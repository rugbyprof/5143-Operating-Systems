---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys"
# footer: "What is an OS Really Doing (scaffolding with OpenAI GPT-5)"
# style: ../assets/msu-theme.css
style:
  section {
    font-size: 0.8em; /* shrink all slide text slightly */
  }
  pre code {
    font-size: 0.6em;
  }
---

# ğŸ§© **4. File Systems and Persistent Storage**

---

## ğŸ—ƒï¸ **What a File System Actually Does**

A filesystem is responsible for:

- **Storing data** (obviously)
- **Finding data** (less obviously)
- **Keeping data correct**, even after crashes
- **Organizing** files into directories
- **Securing** access with permissions
- **Mapping** human-friendly paths â†’ physical locations
- **Decoupling** storage hardware from software expectations

> **Think of it as a librarian who never sleeps and never forgives sloppy metadata.**

---

## ğŸ“ **The Filesystem Abstraction Layer**

From a programâ€™s perspective:

```
/home/terry/project/data.json
```

â€¦looks like a simple hierarchical path.

Under the hood:

- Itâ€™s a tree of directory entries
- Each leaf points to an **inode**

---

## ğŸ“ **The Filesystem Abstraction Layer**

- Inode describes:
  - owner, permissions
  - timestamps
  - which blocks hold file data
  - type (file, directory, link)
    **Programs never see physical blocks.  
    They see clean structure.  
    The filesystem hides the chaos.**

<br><br><br>

---

## ğŸ“¦ **Inodes: The â€œObjectsâ€ That Store Metadata**

An inode contains:

- File type
- Permissions
- Owner / group
- Size
- Timestamps (create, modify, access)
- Pointers to the fileâ€™s data blocks

Data is **not stored inside the inode** â€” the inode stores _where_ the data is.

> **Analogy:** An inode is a passport + treasure map for your file.

---

## ğŸ—‚ï¸ **Blocks: The Storage Unit of Choice**

Filesystems break storage into fixed-size **blocks**  
(commonly 4 KB, though 1KBâ€“64KB exist).

Why blocks?

- Efficient allocation
- Compatible with physical media
- Easy to cache
- Supports partial reads/writes
- Helps avoid fragmentation chaos

---

## ğŸ§µ **How Files Are Mapped to Blocks**

Three classic strategies:

### **1. Contiguous Allocation**

- File blocks are consecutive on disk
- Fast sequential reads
- Simple metadata
- BUT: terrible external fragmentation
- Used in old-school filesystems and game consoles

---

## ğŸ§µ **How Files Are Mapped to Blocks**

### **2. Linked Allocation**

- Each block points to the next
- Easy growth, no fragmentation
- Terrible random access performance
- Used by FAT in earlier eras

---

## ğŸ§µ **How Files Are Mapped to Blocks**

### **3. Indexed Allocation (modern approach)**

- inode contains a table of block pointers
- Supports:
  - direct pointers (first few blocks)
  - indirect pointers (tree structures)
- Scales to large files
- Enables random access
- Used by ext2/ext3/ext4, XFS, NTFS, APFS (with variations)

---

## ğŸ—ƒï¸ **Directory Structures**

Typical modern FS uses:

- **Hierarchy**
  - directories can contain files & subdirectories
- **Directory entries**
  - mapping: name â†’ inode
- **Special entries**
  - â€œ.â€ = current directory
  - â€œ..â€ = parent directory

---

## ğŸ—ƒï¸ **Directory Structures**

This design supports:

- path resolution
- permissions
- symbolic links
- mount points

---

## ğŸ” **Permissions & Security (High-Level)**

Every file/directory typically has:

- owner
- group
- world

And permission triads:

- read
- write
- execute

---

## ğŸ” **Permissions & Security (High-Level)**

Plus additional metadata:

- sticky bits
- ACLs
- extended attributes

> Enough flexibility to enforce isolation, not enough to prevent clever undergrads from trying to break it.

---

## ğŸ’£ **Journaling & Crash Recovery**

Modern filesystems **journal** metadata (and sometimes data) to recover from crashes.

Why?

Imagine:

- Program writing file metadata halfway
- Power fails
- You reboot
- You now own a filesystem-shaped crime scene

---

## ğŸ’£ **Journaling & Crash Recovery**

Journaling ensures:

- operations are atomic
- metadata updates can be replayed
- consistency is preserved

Ext4, NTFS, APFS, XFS all support journaling techniques.

---

## âš¡ **Caching in File Systems**

File systems heavily cache:

- directory entries
- inode metadata
- recently used blocks
- write buffers

---

## âš¡ **Caching in File Systems**

This leads to:

- faster read performance
- delayed writes (â€œwrite-backâ€)
- flushes on fsync()
- surprising behavior:
  - writing to a file doesnâ€™t always hit disk immediately
  - deleting a file frees space _but not necessarily actual blocks right away_

> â€œSaving your fileâ€ really means  
> _â€œIt will eventually be saved. Probably.â€_

---

## ğŸ’½ **SSDs & Wear Leveling: The Hidden Machinery**

SSDs donâ€™t overwrite blocks in place. They:

- write to new physical cells
- remap logical â†’ physical
- garbage-collect old blocks
- distribute writes evenly to prevent cell death

SSD internals include:

- flash translation layer (FTL)
- block erasure cycles
- bad-block management
- unpredictable latencies

---

## ğŸ’½ **SSDs & Wear Leveling: The Hidden Machinery**

This affects performance:

- small writes become large internal operations
- cheap SSDs stutter during garbage collection
- high-end ones use DRAM caches to mask this

---

## ğŸš€ **How File Systems Have Evolved on SSDs**

Modern FS adapt to SSD traits:

- **APFS** and **Btrfs**: copy-on-write
- **F2FS**: flash-friendly layout
- **ZFS**: checksumming & self-healing
- **Ext4**: solid, conservative workhorse

Everything is now optimized for:

- fast random reads
- fewer unnecessary writes
- longevity of flash cells

---

## ğŸ“¦ **High-Level Example: Writing a File**

```
write("hello")
    â†“
Kernel copies bytes into a buffer
    â†“
Dirty pages marked for flush
    â†“
Filesystem journal logs metadata intent
    â†“
Data written to blocks
    â†“
Metadata updated (inode, timestamps)
    â†“
Journal commit
    â†“
Filesystem is consistent
```

---

## ğŸ“¦ **High-Level Example: Writing a File**

Not instantaneous.  
Not simple.  
But highly optimized.

---

## ğŸ§ª **File System Inspections: Fun Commands**

Great for students:

```
df -h        # disk usage
du -sh *     # directory sizes
lsblk        # block device mapping
stat file    # inode metadata
sudo blkid   # filesystem types
mount        # whatâ€™s mounted where
```

Use these to show real-world filesystem behavior.

---

## ğŸ§² **Summary Slide**

- Filesystems map **names â†’ inodes â†’ blocks**
- Inodes store metadata, not file data
- Blocks store the actual bytes
- Journaling prevents corruption
- SSDs add complexity: wear leveling, FTL, garbage collection
- Modern FS adapt to flash-based storage
- OS caches aggressively to improve performance
- Paths and directories are just abstractions layered on top

> **â€œA filesystem is part librarian, part accountant, part magician
> and it never forgets who modified what at 2:37 AM.â€**
