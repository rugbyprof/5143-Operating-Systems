---
marp: true
theme: border
paginate: true
header: "ğŸ´ MSU OpSys"
# footer: "What is an OS Really Doing (scaffolding with OpenAI GPT-5)"
# style: ../assets/msu-theme.css
style:
  section {
    font-size: 0.8em; /* shrink all slide text slightly */
  }
  pre code {
    font-size: 0.6em;
  }
---

# ğŸ§© **2. Paging & Virtual Memory**

---

## ğŸ§  **Why Paging Exists**

- Physical memory is small, fragmented, and shared.
- Programs want:
  - large, clean, contiguous memory
  - stable addresses
  - the ability to grow
- Paging solves fragmentation by breaking memory into **uniform chunks**.

> **Think: pizza slices.  
> Itâ€™s easier to move slices around than whole pizzas.**

---

## ğŸ“¦ **Pages and Frames (4 KB Mental Model)**

- Virtual memory is divided into **pages** (fixed size blocks).
- Physical RAM is divided into **frames** (same size).
- A page can live:
  - in RAM
  - on disk (swap)
  - not present yet (demand paging)
  - shared across processes (shared libs, fork COW)

---

## ğŸ“¦ **Pages and Frames (4 KB Mental Model)**

This uniformity simplifies:

- allocation
- swapping
- caching
- protection
- performance management

---

## ğŸ—ºï¸ **Address Translation (Zoomed in)**

A virtual address is split into:

- **Page number** (which page?)
- **Offset** (where inside that page?)

MMU does:

```
virtual_page â†’ page_table[virtual_page] â†’ frame_number
physical_address = frame_number + offset
```

No math required â€” concept only.

> **TL;DR:** The MMU is a hardware dictionary of page mappings.

---

## ğŸš¨ **Page Faults: When the OS Goes â€œHang Onâ€¦â€**

A page fault occurs when:

- page not loaded
- page swapped out
- page invalid
- or you asked for something you shouldnâ€™t

---

## ğŸš¨ **Page Faults: When the OS Goes â€œHang Onâ€¦â€**

The OS responds by:

1. Pausing the process
2. Locating the page (disk/pagefile)
3. Loading it into a frame
4. Updating the page table
5. Resuming the process

### Key idea:

**Page faults are normal. Thrashing is not.**

---

## ğŸ”„ **Demand Paging**

- Only load pages **when theyâ€™re actually used**.
- Saves time + memory.
- Works great until programs start accessing too many missing pages.

---

## ğŸ”¥ **Thrashing: When the OS Has a Meltdown**

Thrashing = when system spends more time **swapping** than **running**.

Symptoms:

- CPU idle (ironically)
- Disk usage at 100%
- System feels frozen
- Mouse lags
- Students ask: â€œIs my laptop dying?â€

**Cause: Working set > available RAM.**

---

## ğŸ”¥ **Thrashing: When the OS Has a Meltdown**

**The Fix:**

- More RAM
- Fewer programs
- Better paging strategy
- Increase locality (compiler-level optimizations)

---

## ğŸ” **Page Replacement Policies**

When memory is full and the OS needs space:

### **FIFO**

- Easiest
- Worst for locality
- â€œOldest goes firstâ€
- Leads to **Beladyâ€™s anomaly** (adding RAM makes things worse!)

### **LRU**

- Best general-purpose heuristic
- â€œKick out the page unused the longestâ€
- Approximated using timestamps or counters

---

## ğŸ” **Page Replacement Policies**

### **Optimal (OPT)**

- â€œKick out the page that will be used farthest in the future.â€
- Impossible to implement (requires time travel).
- Useful as a teaching benchmark.

---

## ğŸ“ˆ **Working Set Model (High-Level)**

Processes have a â€œworking setâ€ of pages they currently need.

If working set â‰¤ RAM â†’ smooth performance  
If working set > RAM â†’ thrashing â†’ sadness â†’ Slack meltdown

This is where paging meets **performance**.

---

## ğŸ“ **Paging Summary Slide**

- Pages/frames = fixed-size blocks
- MMU handles translation
- Page faults = normal
- Thrashing = OS purgatory
- Page replacement = eviction strategies
- Demand paging = load-on-first-use
